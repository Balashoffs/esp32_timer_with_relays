# Основные модули прошивки ESP32

## 1. **System.Device.Gpio** - Управление GPIO

### Назначение
Базовый модуль nanoFramework для работы с цифровыми входами/выходами (GPIO) микроконтроллера ESP32.

### Основные классы

#### GpioController
- **Что делает:** Управляет всеми GPIO пинами устройства
- **Зачем нужен:** Централизованное управление всеми цифровыми выводами
- **Основные методы:**
    - `OpenPin(int pinNumber, PinMode mode)` - открывает пин для работы
    - Автоматически управляет ресурсами пинов

#### GpioPin
- **Что делает:** Представляет отдельный GPIO пин
- **Зачем нужен:** Позволяет читать/записывать значения на конкретный пин
- **Основные методы:**
    - `Write(PinValue value)` - устанавливает HIGH (1) или LOW (0)
    - `Read()` - читает текущее состояние пина
    - `SetPinMode(PinMode mode)` - настраивает режим работы

#### PinMode (Enum)
Режимы работы пина:
- **Output** - выход (для управления реле, LED)
- **Input** - вход (для кнопок, датчиков)
- **InputPullUp** - вход с подтягивающим резистором
- **InputPullDown** - вход с стягивающим резистором

#### PinValue (Enum)
Логические уровни:
- **High** - высокий уровень (3.3V на ESP32)
- **Low** - низкий уровень (0V)

### Применение в проекте
```csharp
// Инициализация контроллера
GpioController gpioController = new GpioController();

// Открытие пина 16 как выход для реле
GpioPin relayPin = gpioController.OpenPin(16, PinMode.Output);

// Включение реле
relayPin.Write(PinValue.High);

// Выключение реле
relayPin.Write(PinValue.Low);
```

### Почему это важно
- **Безопасность:** Предотвращает конфликты при одновременном доступе к пинам
- **Абстракция:** Скрывает сложность работы с регистрами микроконтроллера
- **Кроссплатформенность:** Один и тот же код работает на разных ESP32 платах

---

## 2. **System.Device.Adc** - Аналого-цифровое преобразование

### Назначение
Модуль для работы с аналоговыми входами ESP32, преобразующий аналоговое напряжение (0-3.3V) в цифровое значение (0-4095).

### Основные классы

#### AdcController
- **Что делает:** Управляет всеми ADC каналами микроконтроллера
- **Зачем нужен:** Координирует доступ к аналоговым входам
- **Характеристики ESP32:**
    - 2 контроллера ADC (ADC1 и ADC2)
    - 18 каналов (GPIO 32-39 для ADC1, GPIO 0, 2, 4, 12-15, 25-27 для ADC2)
    - 12-битное разрешение (0-4095)

#### AdcChannel
- **Что делает:** Представляет один канал АЦП
- **Зачем нужен:** Читает аналоговое напряжение с конкретного GPIO
- **Основные методы:**
    - `ReadValue()` - возвращает значение от 0 до 4095
    - `ReadRatio()` - возвращает значение от 0.0 до 1.0

### Как работает ADC

```
Аналоговое напряжение → АЦП → Цифровое значение

0.0V    → 0
1.65V   → 2047 (середина)
3.3V    → 4095 (максимум)
```

### Применение в проекте

```csharp
// Инициализация контроллера ADC
AdcController adcController = new AdcController();

// Открытие канала 4 (GPIO 32)
AdcChannel channel4 = adcController.OpenChannel(4);

// Чтение значения
int value = channel4.ReadValue(); // Например, 2650

// Определение нажатой кнопки по диапазону
if (value >= 2600 && value <= 2700)
{
    // Нажата кнопка Program 2
}
```

### Резистивный делитель для кнопок

Проект использует резистивную матрицу кнопок:

```
    3.3V
     |
    [R1]
     |-----> К ADC
    [Кнопка1] → GND
     |
    [R2]
     |-----> К ADC
    [Кнопка2] → GND
     |
    [R3]
     |
    GND
```

Каждая кнопка создает уникальное напряжение при нажатии:
- **Кнопка 1:** ~1.95V → ADC значение ~1900-2000
- **Кнопка 2:** ~2.65V → ADC значение ~2600-2700
- **Кнопка 3:** ~3.30V → ADC значение ~3250-3350

### Почему это важно
- **Экономия пинов:** 3-5 кнопок на одном аналоговом входе
- **Простота схемотехники:** Меньше проводов, проще разводка платы
- **Надежность:** Нет проблем с дребезгом контактов при правильных резисторах

---

## 3. **System.Threading** - Многопоточность и таймеры

### Назначение
Модуль для работы с потоками, задержками и периодическими задачами.

### Основные классы

#### Thread
- **Что делает:** Управляет выполнением кода
- **Зачем нужен:** Организация многозадачности в прошивке
- **Основные методы:**
    - `Sleep(int milliseconds)` - останавливает выполнение на заданное время
    - `Sleep(Timeout.Infinite)` - останавливает поток навсегда (для main)

#### Timer
- **Что делает:** Выполняет код через определенные интервалы
- **Зачем нужен:** Периодическое сканирование кнопок, обновление состояния
- **Конструктор:**
```csharp
Timer timer = new Timer(
    callback,        // Метод для вызова
    state,           // Объект состояния (может быть null)
    dueTime,         // Задержка до первого вызова (мс)
    period           // Интервал между вызовами (мс)
);
```

#### Timeout
- **Что делает:** Предоставляет константы для таймеров
- **Зачем нужен:** Читаемость кода
- **Константы:**
    - `Timeout.Infinite` - бесконечное ожидание

### Применение в проекте

```csharp
// Основной поток: ждет вечно, вся работа в таймерах
Thread.Sleep(Timeout.Infinite);

// Таймер для сканирования кнопок каждые 250 мс
_timer = new Timer(
    _OnScanButtons,  // Метод проверки кнопок
    null,            // Состояние не используется
    0,               // Первый вызов сразу
    250              // Повторять каждые 250 мс
);

// Задержка для устранения дребезга LED
Thread.Sleep(125);
```

### Архитектура потоков в проекте

```
Main Thread (спит)
    ↓
Timer Thread (ADC сканирование каждые 250 мс)
    ↓
HighResTimer Threads (нагрев/охлаждение/LED)
```

### Почему это важно
- **Отзывчивость:** Система реагирует на кнопки без блокировки
- **Экономия энергии:** CPU может переходить в режим сна между событиями
- **Точность:** Периодические задачи выполняются строго по времени

---

## 4. **nanoFramework.Hardware.Esp32** - Специфические функции ESP32

### Назначение
Модуль с функциями, специфичными для микроконтроллера ESP32.

### Основные возможности

#### HighResTimer
- **Что делает:** Высокоточный таймер на основе аппаратного таймера ESP32
- **Зачем нужен:** Управление реле с микросекундной точностью
- **Характеристики:**
    - Разрешение: 1 микросекунда (1 мкс = 0.000001 сек)
    - Аппаратная реализация (не зависит от загрузки CPU)
    - Поддержка периодических и одноразовых событий

**Методы:**
```csharp
// Создание таймера
HighResTimer timer = new HighResTimer();

// Периодический таймер (повторяется)
timer.StartOnePeriodic(microseconds);

// Остановка
timer.Stop();

// Освобождение ресурсов
timer.Dispose();

// Событие при срабатывании
timer.OnHighResTimerExpired += (sender, args) => {
    // Код выполняется при срабатывании таймера
};
```

#### Configuration
- **Что делает:** Настройка специфичных параметров ESP32
- **Возможности:**
    - Настройка частоты CPU
    - Управление WiFi/Bluetooth
    - Конфигурация пинов с альтернативными функциями
    - Настройка power management

#### Sleep
- **Что делает:** Режимы энергосбережения ESP32
- **Типы:**
    - **Light Sleep** - CPU остановлен, периферия работает
    - **Deep Sleep** - все выключено кроме RTC
    - **Modem Sleep** - только WiFi/Bluetooth выключены

### Применение в проекте

```csharp
// Таймер для управления нагревом (4 минуты = 240,000,000 мкс)
HighResTimer heatingTimer = new HighResTimer();
ulong heatingUs = 240_000_000; // 240 секунд в микросекундах

// Запуск однократного таймера
heatingTimer.StartOnePeriodic(heatingUs);

// Обработчик срабатывания
heatingTimer.OnHighResTimerExpired += (sender, e) => {
    // Выключить нагрев
    relayPin.Write(PinValue.Low);
    
    // Запустить таймер охлаждения
    coolingTimer.StartOnePeriodic(coolingUs);
};
```

### Преимущества HighResTimer

| Характеристика | Timer (System.Threading) | HighResTimer (ESP32) |
|----------------|--------------------------|----------------------|
| Точность | ±10-50 мс | ±1 мкс |
| Минимальный интервал | ~15 мс | 1 мкс |
| Зависит от CPU | Да | Нет (аппаратный) |
| Энергопотребление | Среднее | Низкое |

### Почему это важно
- **Точность:** Критично для длительных программ (погрешность <0.001%)
- **Надежность:** Аппаратный таймер работает независимо от загрузки CPU
- **Масштабируемость:** Можно запускать несколько таймеров одновременно

---

## 5. **System** - Базовые типы и функции

### Назначение
Основная библиотека .NET с базовыми типами данных и функциями.

### Основные компоненты

#### TimeSpan
- **Что делает:** Представляет временной интервал
- **Зачем нужен:** Удобная работа со временем в читаемом виде
- **Методы создания:**
```csharp
TimeSpan.FromSeconds(30)      // 30 секунд
TimeSpan.FromMinutes(4)       // 4 минуты
TimeSpan.FromHours(8)         // 8 часов
TimeSpan.FromMilliseconds(500) // 0.5 секунды
```

**Свойства:**
- `Ticks` - количество "тиков" (1 тик = 100 наносекунд)
- `TotalSeconds` - общее количество секунд
- `TotalMilliseconds` - общее количество миллисекунд

#### EventHandler / EventArgs
- **Что делает:** Механизм событий для связи между компонентами
- **Зачем нужен:** Слабая связанность (loose coupling) модулей
- **Паттерн:**
```csharp
// Объявление события
public EventHandler OnButtonPressed;

// Создание аргументов события
public class ButtonEventArgs : EventArgs
{
    public ButtonType Type { get; set; }
}

// Вызов события
OnButtonPressed?.Invoke(this, new ButtonEventArgs { Type = ButtonType.Program1 });

// Подписка на событие
adcService.OnButtonPressed += (sender, args) => {
    ButtonType type = ((ButtonEventArgs)args).Type;
    // Обработка нажатия
};
```

#### Exception
- **Что делает:** Обработка ошибок
- **Зачем нужен:** Контроль исключительных ситуаций
- **Типы:**
    - `ArgumentOutOfRangeException` - неверный аргумент
    - `InvalidOperationException` - недопустимая операция
    - `NullReferenceException` - обращение к null

#### Console
- **Что делает:** Вывод отладочной информации
- **Зачем нужен:** Диагностика и мониторинг работы устройства
- **Методы:**
```csharp
Console.WriteLine("Status: Heating");  // С переносом строки
Console.Write("Value: ");              // Без переноса
```

### Применение в проекте

```csharp
// TimeSpan для читаемости времени
public TimeSpan Program1Ts => TimeSpan.FromHours(8);

// Конвертация в микросекунды для HighResTimer
ulong microseconds = (ulong)timeSpan.Ticks / 10;

// События для связи модулей
heatService.HeatingActionEventHandler += (sender, args) => {
    HeatingStatus status = ((HeatingActionEventArgs)args).Status;
    Console.WriteLine("Status: " + status.ToString());
};

// Обработка ошибок
switch (buttonType)
{
    case ButtonType.Program1:
        // ...
        break;
    default:
        throw new ArgumentOutOfRangeException();
}
```

---

## Взаимодействие модулей в проекте

```
┌─────────────────────────────────────────────────────────────┐
│                         System                               │
│  (TimeSpan, EventHandler, Console, Exception)               │
└────────────────────────┬────────────────────────────────────┘
                         │
         ┌───────────────┼───────────────┐
         ▼               ▼               ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────────┐
│ System.Device│  │ System.Device│  │nanoFramework.    │
│    .Gpio     │  │    .Adc      │  │Hardware.Esp32    │
│              │  │              │  │                  │
│ GpioController│  │AdcController │  │HighResTimer      │
│ GpioPin      │  │ AdcChannel   │  │Configuration     │
└──────┬───────┘  └──────┬───────┘  └────────┬─────────┘
       │                 │                    │
       ▼                 ▼                    ▼
┌─────────────────────────────────────────────────────┐
│              System.Threading                        │
│        (Thread, Timer, Timeout)                     │
└──────────────────────┬──────────────────────────────┘
                       │
                       ▼
              ┌────────────────┐
              │  Приложение    │
              │  (Program.cs)  │
              └────────────────┘
```

---

## Итоговая таблица модулей

| Модуль | Основное назначение | Ключевые классы | Частота использования |
|--------|---------------------|-----------------|----------------------|
| **System.Device.Gpio** | Управление цифровыми выводами | GpioController, GpioPin | Постоянно |
| **System.Device.Adc** | Чтение аналоговых сигналов | AdcController, AdcChannel | Каждые 250 мс |
| **System.Threading** | Многозадачность и задержки | Thread, Timer | Постоянно |
| **nanoFramework.Hardware.Esp32** | Высокоточные таймеры | HighResTimer | Для нагрева/охлаждения |
| **System** | Базовые типы и функции | TimeSpan, EventHandler, Console | Повсеместно |

---

## Рекомендации по использованию

### Когда использовать каждый модуль:

1. **GPIO** - для всех цифровых сигналов (реле, LED, кнопки с дискретным входом)
2. **ADC** - для аналоговых датчиков (температура, напряжение, резистивные кнопки)
3. **Timer (Threading)** - для задач с точностью 10+ мс (опрос кнопок, UI обновления)
4. **HighResTimer** - для задач с точностью <10 мс (PWM, длительные таймеры)
5. **TimeSpan** - всегда для работы со временем (читаемость и безопасность)
6. **Events** - для связи между модулями (слабая связанность)

Эти модули составляют фундамент прошивки и обеспечивают все необходимые функции для работы устройства управления нагревом.
